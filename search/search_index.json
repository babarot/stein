{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Stein # Stein is a linter for config files with a customizable rule set. Supported config file types are JSON, YAML and HCL for now. The basic design of this tool are heavily inspired by HashiCorp Sentinel and its lots of implementations come from Terraform . Motivation # As the motivation of this tool, the factor which accounts for the most of them is the Policy as Code . Thanks to Infrastructure as Code , the number of cases that the configurations of its infrastructure are described as code is increasing day by day. Then, it became necessary to set the lint or policy for the config files. As an example: the namespace of Kubernetes to be deployed, the number of replicas of Pods, the naming convention of a namespace, etc. This tool makes it possible to describe those requests as code (called as the rules ).","title":"Home"},{"location":"#stein","text":"Stein is a linter for config files with a customizable rule set. Supported config file types are JSON, YAML and HCL for now. The basic design of this tool are heavily inspired by HashiCorp Sentinel and its lots of implementations come from Terraform .","title":"Stein"},{"location":"#motivation","text":"As the motivation of this tool, the factor which accounts for the most of them is the Policy as Code . Thanks to Infrastructure as Code , the number of cases that the configurations of its infrastructure are described as code is increasing day by day. Then, it became necessary to set the lint or policy for the config files. As an example: the namespace of Kubernetes to be deployed, the number of replicas of Pods, the naming convention of a namespace, etc. This tool makes it possible to describe those requests as code (called as the rules ).","title":"Motivation"},{"location":"commands/_index/","text":"Stein is controlled via a very easy to use command-line interface (CLI). Stein is only a single command-line application: stein . This application then takes a subcommand such as \"apply\" or \"plan\". The complete list of subcommands is in the navigation to the left. The Stein CLI is a well-behaved command line application. In erroneous cases, a non-zero exit status will be returned. It also responds to -h and --help as you'd expect. To view a list of the available commands at any time, just run stein with no arguments. To view a list of the available commands at any time, just run stein with no arguments: $ stein Usage: stein [--version] [--help] <command> [<args>] Available commands are: apply Applies a policy to arbitrary config files. fmt Formats a policy source to a canonical format. To get help for any specific command, pass the -h flag to the relevant subcommand. For example, to see help about the apply subcommand: $ stein apply -h Usage of apply: Applies a policy to arbitrary config files. Options: -policy string path to the policy files or the directory where policy files are located Shell Tab-completion # TBD Debug stein # Stein has detailed logs which can be enabled by setting the STEIN_LOG environment variable to any value. This will cause detailed logs to appear on stderr. You can set STEIN_LOG to one of the log levels TRACE , DEBUG , INFO , WARN or ERROR to change the verbosity of the logs. TRACE is the most verbose and it is the default if STEIN_LOG is set to something other than a log level name. To persist logged output you can set STEIN_LOG_PATH in order to force the log to always be appended to a specific file when logging is enabled. Note that even when STEIN_LOG_PATH is set, STEIN_LOG must be set in order for any logging to be enabled. If you find a bug with Stein, please include the detailed log by using a service such as gist.","title":"Stein CLI Commands"},{"location":"commands/_index/#shell-tab-completion","text":"TBD","title":"Shell Tab-completion"},{"location":"commands/_index/#debug-stein","text":"Stein has detailed logs which can be enabled by setting the STEIN_LOG environment variable to any value. This will cause detailed logs to appear on stderr. You can set STEIN_LOG to one of the log levels TRACE , DEBUG , INFO , WARN or ERROR to change the verbosity of the logs. TRACE is the most verbose and it is the default if STEIN_LOG is set to something other than a log level name. To persist logged output you can set STEIN_LOG_PATH in order to force the log to always be appended to a specific file when logging is enabled. Note that even when STEIN_LOG_PATH is set, STEIN_LOG must be set in order for any logging to be enabled. If you find a bug with Stein, please include the detailed log by using a service such as gist.","title":"Debug stein"},{"location":"commands/apply/","text":"The stein apply command is used to execute a policy locally for development purposes. Usage : stein apply [ options ] POLICY This command executes the policy file at the path specified by POLICY. The output will indicate whether the policy passed or failed. The exit code also reflects the status of the policy: 0 is pass, 1 is fail, 2 is undefined (fail, but because the result was undefined), and 2 is a runtime error. A configuration file can be specified with -policy to define available import plugins, mock data, and global values. This is used to simulate a policy embedded within an application. The documentation for this configuration file is below. The command-line flags are all optional. The list of available flags are: -policy=file[,file,dir,...] - Path to HCL file path or a directory path located in HCL files. You can specify multiple paths (directory or just HCL file) with a comma. The STEIN_POLICY variable is the environment variable version of this flag. See also How policies are loaded by Stein","title":"Command: apply"},{"location":"commands/fmt/","text":"The stein fmt command formats a policy source to a canonical format. Usage : stein fmt [ options ] FILE ... This command formats all the specified policy files to a canonical format. By default, policy files are overwritten in place. This behavior can be changed with the -write flag. If a specified FILE is - then stdin is read and the output is always written to stdout. The command-line flags are all optional. The list of available flags are: -write=true - Write formatted policy to the named source file. If false, output will go to stdout. If multiple files are specified, the output will be concatenated directly. -check=false - Don't format, only check if formatting is necessary. Files that require formatting are printed, and a non-zero exit code is returned if changes are required. $ stein fmt -check test.hcl config { - report { format = \"{{.Level}}: {{.Rule}}: {{.Message}}\" - style = \"console\" - color = true + style = \"console\" + color = true } - }","title":"Command: fmt"},{"location":"concepts/policy-as-code/","text":"Policy as Code # Policy as code is the idea of writing code in a high-level language to manage and automate policies. By representing policies as code in text files, proven software development best practices can be adopted such as version control, automated testing, and automated deployment. Many existing policy or ACL systems do not practice policy as code. Many policies are set by clicking in a GUI, which isn't easily repeatable nor versionable. They usually don't provide any system for testing policies other than testing an action that would violate the policy. This makes it difficult for automated testing. And the policy language itself varies by product. Stein is built around the idea and provides all the benefits of policy as code. Note The idea of \"Policy as Code\" is proposed by HashiCorp and HashiCorp Sentinel. Policy as Code - Sentinel by HashiCorp","title":"Policy as Code"},{"location":"concepts/policy-as-code/#policy-as-code","text":"Policy as code is the idea of writing code in a high-level language to manage and automate policies. By representing policies as code in text files, proven software development best practices can be adopted such as version control, automated testing, and automated deployment. Many existing policy or ACL systems do not practice policy as code. Many policies are set by clicking in a GUI, which isn't easily repeatable nor versionable. They usually don't provide any system for testing policies other than testing an action that would violate the policy. This makes it difficult for automated testing. And the policy language itself varies by product. Stein is built around the idea and provides all the benefits of policy as code. Note The idea of \"Policy as Code\" is proposed by HashiCorp and HashiCorp Sentinel. Policy as Code - Sentinel by HashiCorp","title":"Policy as Code"},{"location":"concepts/policy/","text":"What's a policy? # The policy describes the rule \"The configuration file should be written like this\". How the configuration file should be written depends on the company and team. Stein respects and embraces the approaches adopted by Terraform and HashiCorp Sentinel so that it can be defined flexibly. Stein can test against the configuration file based on those policies. Therefore, by combining with CI etc., you can enforce rules on the configuration file. Why needs policies? # Nowadays, thanks to the infiltration of the concept of \"Infrastructure as Code\", many infrastructure settings are coded in a configuration file language such as YAML. For YAML files that we have to maintain like Kubernetes manifest files, as we continue to maintain them in the meantime, we will want to unify the writing style with policies like a style guide. Let's say reviewing Kubernetes YAML. In many cases, you will find points to point out repeatedly in repeated reviews. For example, explicitly specifying namespace, label, and so on. The things that humans point out every time should be checked mechanically beforehand. It's important for reviewers as well as for reviewees. Besides, there are points that can not be pointed out in the review, and a lot of difficult points to comment. For example, it's whether the specified namespace name is correct or not. In addition, let's say Terraform use-case. As an example: before infrastructure as code and autoscaling, if an order came through for 5,000 new machines, a human would likely respond to the ticket verifying that the user really intended to order 5,000 new machines. Today, automation can almost always freely order 5,000 new compute instances without any hesitation, which can result in unintended expense or system instability ( HashiCorp Sentinel has basically the same intention and Stein's one also comes from that). In order to avoid these accidents in advance, it is very important to define policies as codes and warn them based on them.","title":"Policy"},{"location":"concepts/policy/#whats-a-policy","text":"The policy describes the rule \"The configuration file should be written like this\". How the configuration file should be written depends on the company and team. Stein respects and embraces the approaches adopted by Terraform and HashiCorp Sentinel so that it can be defined flexibly. Stein can test against the configuration file based on those policies. Therefore, by combining with CI etc., you can enforce rules on the configuration file.","title":"What's a policy?"},{"location":"concepts/policy/#why-needs-policies","text":"Nowadays, thanks to the infiltration of the concept of \"Infrastructure as Code\", many infrastructure settings are coded in a configuration file language such as YAML. For YAML files that we have to maintain like Kubernetes manifest files, as we continue to maintain them in the meantime, we will want to unify the writing style with policies like a style guide. Let's say reviewing Kubernetes YAML. In many cases, you will find points to point out repeatedly in repeated reviews. For example, explicitly specifying namespace, label, and so on. The things that humans point out every time should be checked mechanically beforehand. It's important for reviewers as well as for reviewees. Besides, there are points that can not be pointed out in the review, and a lot of difficult points to comment. For example, it's whether the specified namespace name is correct or not. In addition, let's say Terraform use-case. As an example: before infrastructure as code and autoscaling, if an order came through for 5,000 new machines, a human would likely respond to the ticket verifying that the user really intended to order 5,000 new machines. Today, automation can almost always freely order 5,000 new compute instances without any hesitation, which can result in unintended expense or system instability ( HashiCorp Sentinel has basically the same intention and Stein's one also comes from that). In order to avoid these accidents in advance, it is very important to define policies as codes and warn them based on them.","title":"Why needs policies?"},{"location":"configuration/_index/","text":"Stein uses text files to describe infrastructure and to set variables. These text files are called Stein Policy Configuration and end in just .hcl . This section talks about the format of these files as well as how they're loaded. The format of the policy files are able to be in extended HCL (called as Stein format). The Stein format is more human-readable, supports comments, and is the generally recommended format for most Stein files. The JSON format is meant for machines to create, modify, and update, but can also be done by Stein operators if you prefer. Click a sub-section in the navigation to the left to learn more about Stein configuration.","title":"Introduction"},{"location":"configuration/load/","text":"How policies are loaded by Stein # To understand how stein loads policy files and recognizes them is very important for writing and applying policies to the files effectively. stein apply requires always one or more arguments only. It assumes the config file paths such as YAML, JSON and so on. The path may have a hierarchical structure. In Stein, when a path with a hierarchical structure is given as arguments, stein recognizes the HCL file in .policy directory placed in the path included in that path as a policy to be applied. Let's see a concrete example. _examples |-- .policy/ | |-- config.hcl | |-- functions.hcl | |-- rules.hcl | `-- variables.hcl |-- manifests/ | |-- .policy/ | | |-- functions.hcl | | `-- rules.hcl | `-- microservices/ | |-- x-echo-jp/ | | `-- development/ | | |-- Deployment/ | | | |-- redis-master.yaml | | | |-- test.yaml | | | `-- test.yml | | |-- PodDisruptionBudget/ | | | `-- pdb.yaml | | `-- Service/ | | `-- service.yaml | `-- x-gateway-jp/ | `-- development/ | `-- Deployment/ | `-- test.yaml `-- spinnaker/ |-- .policy/ | `-- functions.hcl `-- x-echo-jp/ `-- development/ `-- deploy-to-dev-v2.yaml There are some Kubernetes YAML with hierarchical structure and some policies here. In this case, stein recognizes these HCL files as the policy to be applied to the arguments if _examples/manifests/microservices/x-echo-jp/development/Deployment/test.yaml is given as arguments of stein : _examples/.policy/*.hcl _examples/manifests/.policy/*.hcl This is because given argument file contains _examples/ and _examples/manifests . That is, all YAML files located in _examples/manifests/ is applied with _examples/.policy/*.hcl and _examples/manifests/.policy/*.hcl . On the other hand, all YAML files located in _examples/spinnaker/ is applied with _examples/.policy/*.hcl and _examples/spinnaker/.policy/*.hcl . So, you can control the policy to apply by appropriately creating the directory and placing the YAML files and .policy directory there. In addition, if you want to apply policies placed in places that have no relation to given arguments, you can control by environment variable or apply flag. export STEIN_POLICY = /path/to/policy stein apply deployment.yaml # or stein apply -policy /path/to/policy deployment.yaml Also STEIN_POLICY ( -policy ) can take multiple values separated by a comma, also can take directories and files: STEIN_POLICY = root-policy/,another-policy/special.hcl # -> these files are applied, besides \".policy/*.hcl\" included in given arguments # root-policy/*.hcl # another-policy/special.hcl","title":"Load Order"},{"location":"configuration/load/#how-policies-are-loaded-by-stein","text":"To understand how stein loads policy files and recognizes them is very important for writing and applying policies to the files effectively. stein apply requires always one or more arguments only. It assumes the config file paths such as YAML, JSON and so on. The path may have a hierarchical structure. In Stein, when a path with a hierarchical structure is given as arguments, stein recognizes the HCL file in .policy directory placed in the path included in that path as a policy to be applied. Let's see a concrete example. _examples |-- .policy/ | |-- config.hcl | |-- functions.hcl | |-- rules.hcl | `-- variables.hcl |-- manifests/ | |-- .policy/ | | |-- functions.hcl | | `-- rules.hcl | `-- microservices/ | |-- x-echo-jp/ | | `-- development/ | | |-- Deployment/ | | | |-- redis-master.yaml | | | |-- test.yaml | | | `-- test.yml | | |-- PodDisruptionBudget/ | | | `-- pdb.yaml | | `-- Service/ | | `-- service.yaml | `-- x-gateway-jp/ | `-- development/ | `-- Deployment/ | `-- test.yaml `-- spinnaker/ |-- .policy/ | `-- functions.hcl `-- x-echo-jp/ `-- development/ `-- deploy-to-dev-v2.yaml There are some Kubernetes YAML with hierarchical structure and some policies here. In this case, stein recognizes these HCL files as the policy to be applied to the arguments if _examples/manifests/microservices/x-echo-jp/development/Deployment/test.yaml is given as arguments of stein : _examples/.policy/*.hcl _examples/manifests/.policy/*.hcl This is because given argument file contains _examples/ and _examples/manifests . That is, all YAML files located in _examples/manifests/ is applied with _examples/.policy/*.hcl and _examples/manifests/.policy/*.hcl . On the other hand, all YAML files located in _examples/spinnaker/ is applied with _examples/.policy/*.hcl and _examples/spinnaker/.policy/*.hcl . So, you can control the policy to apply by appropriately creating the directory and placing the YAML files and .policy directory there. In addition, if you want to apply policies placed in places that have no relation to given arguments, you can control by environment variable or apply flag. export STEIN_POLICY = /path/to/policy stein apply deployment.yaml # or stein apply -policy /path/to/policy deployment.yaml Also STEIN_POLICY ( -policy ) can take multiple values separated by a comma, also can take directories and files: STEIN_POLICY = root-policy/,another-policy/special.hcl # -> these files are applied, besides \".policy/*.hcl\" included in given arguments # root-policy/*.hcl # another-policy/special.hcl","title":"How policies are loaded by Stein"},{"location":"configuration/policy/config/","text":"The config is a block that can describe settings related to stein lint. Basically stein configuration is based on \"Smart default\" concept. It means that it has been set up sufficiently from the beginning. Moreover, this means that you can use it without having to define this block and no need to change the setting. However, depending on the item, you may want to customize it. Therefore, you can change the setting according to the config block accordingly. This page assumes you're familiar with the configuration syntax already. Example # A config configuration looks like the following: config { report { format = \"${format(\"{{.Level}}: {{.Rule}} %s\", color(\"{{.Message}}\", \"white\"))}\" style = \"console\" color = true } } Description # Only one config block can be defined. Within the block (the { } ) is configuration for the config block. Meta-parameters # There are meta-parameters available to config block: report (configuration block) - format (string) - Report message format. It's shown in lint message. In format, it can be described with Go template . {{ .Level }} is converted to the lint level, {{ .Rule }} is converted to the rule name, and {{ .Message }} is converted to the lint message. style (string) - Report style. It can take \"console\", \"inline\" now. color (bool) - Whether to color output. If config block isn't defined, the following configuration is used by default. config { report { format = \"${format(\"[{{.Level}}] {{.Rule}} {{.Message}}\")}\" style = \"console\" color = true } } Syntax # The full syntax is: config { [REPORT] } where REPORT is: report { format = FORMAT style = [console|inline] color = bool }","title":"Config"},{"location":"configuration/policy/config/#example","text":"A config configuration looks like the following: config { report { format = \"${format(\"{{.Level}}: {{.Rule}} %s\", color(\"{{.Message}}\", \"white\"))}\" style = \"console\" color = true } }","title":"Example"},{"location":"configuration/policy/config/#description","text":"Only one config block can be defined. Within the block (the { } ) is configuration for the config block.","title":"Description"},{"location":"configuration/policy/config/#meta-parameters","text":"There are meta-parameters available to config block: report (configuration block) - format (string) - Report message format. It's shown in lint message. In format, it can be described with Go template . {{ .Level }} is converted to the lint level, {{ .Rule }} is converted to the rule name, and {{ .Message }} is converted to the lint message. style (string) - Report style. It can take \"console\", \"inline\" now. color (bool) - Whether to color output. If config block isn't defined, the following configuration is used by default. config { report { format = \"${format(\"[{{.Level}}] {{.Rule}} {{.Message}}\")}\" style = \"console\" color = true } }","title":"Meta-parameters"},{"location":"configuration/policy/config/#syntax","text":"The full syntax is: config { [REPORT] } where REPORT is: report { format = FORMAT style = [console|inline] color = bool }","title":"Syntax"},{"location":"configuration/policy/functions/","text":"It is recommended that you read the Custom Functions page prior to reading this section of the documentation. The page will explain what the custom functions are and how to use them. On the other hands, this documentation will guide you the basics of writing custom functions and introducing it into your policies efficiently. This page assumes you're familiar with the configuration syntax already. Example # A function configuration looks like the following: function \"get_service_name\" { params = [ file ] result = basename ( dirname ( dirname ( dirname ( file )))) } function \"get_env\" { params = [ file ] result = basename ( dirname ( dirname ( file ))) } function \"get_service_id_with_env\" { params = [ file ] result = format ( \"%s-%s\" , get_service_name ( file ), lookup ( var . shortened_environment , get_env ( file ))) } Description # The function block creates an user-defined function of the given NAME (first parameter). The name must be unique. Within the block (the { } ) is configuration for the function. Meta-parameters # There are meta-parameters available to all rules: params (list of strings) - Parameters for the function. Like arguments. It can be referenced within the function. The variable name for params can specify arbitrary string. variadic_param (list of strings) - Variable arguments for the function. result (any) - Return value of the function. It can take just string of course, but also take variables, built-in functions and custom functions even. Syntax # The full syntax is: rule NAME { params = [ARG, ...] [variadic_param = [ARG, ...]] result = RETURN-VALUE }","title":"Functions"},{"location":"configuration/policy/functions/#example","text":"A function configuration looks like the following: function \"get_service_name\" { params = [ file ] result = basename ( dirname ( dirname ( dirname ( file )))) } function \"get_env\" { params = [ file ] result = basename ( dirname ( dirname ( file ))) } function \"get_service_id_with_env\" { params = [ file ] result = format ( \"%s-%s\" , get_service_name ( file ), lookup ( var . shortened_environment , get_env ( file ))) }","title":"Example"},{"location":"configuration/policy/functions/#description","text":"The function block creates an user-defined function of the given NAME (first parameter). The name must be unique. Within the block (the { } ) is configuration for the function.","title":"Description"},{"location":"configuration/policy/functions/#meta-parameters","text":"There are meta-parameters available to all rules: params (list of strings) - Parameters for the function. Like arguments. It can be referenced within the function. The variable name for params can specify arbitrary string. variadic_param (list of strings) - Variable arguments for the function. result (any) - Return value of the function. It can take just string of course, but also take variables, built-in functions and custom functions even.","title":"Meta-parameters"},{"location":"configuration/policy/functions/#syntax","text":"The full syntax is: rule NAME { params = [ARG, ...] [variadic_param = [ARG, ...]] result = RETURN-VALUE }","title":"Syntax"},{"location":"configuration/policy/rules/","text":"The most important thing you'll configure with Stein are rules. Rules are a component of your policies. It might be some rule set such as a region to be deployed, naming convention, or some linting. Or it can be a higher level component such as an email provider, DNS record, or database provider. This page assumes you're familiar with the configuration syntax already. Example # A rule configuration looks like the following: rule \"replicas\" { description = \"Check the number of replicas is sufficient\" conditions = [ \" ${ jsonpath ( \".spec.replicas\" ) > 3 } \", ] report { level = \"ERROR\" message = \"Too few replicas\" } } Description # The rule block creates a rule set of the given NAME (first parameter). The name must be unique. Within the block (the { } ) is configuration for the rule. Meta-parameters # There are meta-parameters available to all rules: description (string) - A human-friendly description for the rule. This is primarily for documentation for users using your Stein configuration. When a module is published in Terraform Registry, the given description is shown as part of the documentation. depends_on (list of strings) - Other rules which this rule depends on. This rule will be skipped if the dependency rules has failed. The rule name which will be described in \"depends_on\" list should follow as \"rule.xxx\". precondition (configuration block; optional) - cases (list of bools) - Conditions to determine whether the rule should be executed. This rule will only be executed if all preconditions return true. conditions (list of bools) - Conditions for deciding whether this rule passes or fails. In order to pass, all conditions must return True. report (configuration block) - level (string) - Error level. It can take \"ERROR\" or \"WARN\" as the level. In case of \"ERROR\", this rule fails. But in case of \"WARN\", this rule doesn't fail. message (string) - Error message. Let's write the conditions for passing the role here. Syntax # The full syntax is: rule NAME { description = DESCRIPTION [depends_on = [NAME, ...]] [PRECONDITION] conditions = [CONDITION, ...] REPORT } where PRECONDITION is: precondition { cases = [CONDITION, ...] } where REPORT is: report { level = [ERROR|WARN] message = MESSAGE }","title":"Rules"},{"location":"configuration/policy/rules/#example","text":"A rule configuration looks like the following: rule \"replicas\" { description = \"Check the number of replicas is sufficient\" conditions = [ \" ${ jsonpath ( \".spec.replicas\" ) > 3 } \", ] report { level = \"ERROR\" message = \"Too few replicas\" } }","title":"Example"},{"location":"configuration/policy/rules/#description","text":"The rule block creates a rule set of the given NAME (first parameter). The name must be unique. Within the block (the { } ) is configuration for the rule.","title":"Description"},{"location":"configuration/policy/rules/#meta-parameters","text":"There are meta-parameters available to all rules: description (string) - A human-friendly description for the rule. This is primarily for documentation for users using your Stein configuration. When a module is published in Terraform Registry, the given description is shown as part of the documentation. depends_on (list of strings) - Other rules which this rule depends on. This rule will be skipped if the dependency rules has failed. The rule name which will be described in \"depends_on\" list should follow as \"rule.xxx\". precondition (configuration block; optional) - cases (list of bools) - Conditions to determine whether the rule should be executed. This rule will only be executed if all preconditions return true. conditions (list of bools) - Conditions for deciding whether this rule passes or fails. In order to pass, all conditions must return True. report (configuration block) - level (string) - Error level. It can take \"ERROR\" or \"WARN\" as the level. In case of \"ERROR\", this rule fails. But in case of \"WARN\", this rule doesn't fail. message (string) - Error message. Let's write the conditions for passing the role here.","title":"Meta-parameters"},{"location":"configuration/policy/rules/#syntax","text":"The full syntax is: rule NAME { description = DESCRIPTION [depends_on = [NAME, ...]] [PRECONDITION] conditions = [CONDITION, ...] REPORT } where PRECONDITION is: precondition { cases = [CONDITION, ...] } where REPORT is: report { level = [ERROR|WARN] message = MESSAGE }","title":"Syntax"},{"location":"configuration/policy/variables/","text":"Input variables serve as parameters for a Terraform module. When used in the root module of a configuration, variables can be set from CLI arguments and environment variables. For child modules , they allow values to pass from parent to child. Input variable usage is introduced in the Getting Started guide section Input Variables . This page assumes you're familiar with the configuration syntax already. Example # Input variables can be defined as follows: variable \"key\" { type = \"string\" } variable \"images\" { type = \"map\" default = { us-east-1 = \"image-1234\" us-west-2 = \"image-4567\" } } variable \"zones\" { default = [ \"us-east-1a\", \"us-east-1b\" ] } Description # The variable block configures a single input variable for a Terraform module. Each block declares a single variable. The name given in the block header is used to assign a value to the variable via the CLI and to reference the variable elsewhere in the configuration. Within the block body (between { } ) is configuration for the variable, which accepts the following arguments: WIP","title":"Variables"},{"location":"configuration/policy/variables/#example","text":"Input variables can be defined as follows: variable \"key\" { type = \"string\" } variable \"images\" { type = \"map\" default = { us-east-1 = \"image-1234\" us-west-2 = \"image-4567\" } } variable \"zones\" { default = [ \"us-east-1a\", \"us-east-1b\" ] }","title":"Example"},{"location":"configuration/policy/variables/#description","text":"The variable block configures a single input variable for a Terraform module. Each block declares a single variable. The name given in the block header is used to assign a value to the variable via the CLI and to reference the variable elsewhere in the configuration. Within the block body (between { } ) is configuration for the variable, which accepts the following arguments: WIP","title":"Description"},{"location":"configuration/syntax/_index/","text":"The syntax of Stein configurations is called HashiCorp Configuration Language (HCL) . It is meant to strike a balance between human readable and editable as well as being machine-friendly. For machine-friendliness, Stein can also read JSON configurations. For general Stein configurations, however, we recommend using the HCL Stein syntax.","title":"Introduction"},{"location":"configuration/syntax/custom-functions/","text":"Info This idea basically comes from hcl2/ext/userfunc at master \u00b7 hashicorp/hcl2 What's custom functions? # The custom function feature is like an user-defined functions. You can freely define functions that Stein doesn't provide as a built-in function . Of course you can define it freely, so you can customize it by wrapping a built-in function, or you can use it like an alias. Why need custom functions? # Stein functions as a versatile testing framework for configuration files such as YAML. Stein therefore doesn't provide a function only to achieve a specific company's use case or purpose. However, there will be many cases in which you want to do it. This custom function feature covers that. Usage # This HCL extension allows a calling application to support user-defined functions. Functions are defined via a specific block type, like this: function \"add\" { params = [ a , b ] result = a + b } function \"list\" { params = [] variadic_param = items result = items } Predefined keywords to be used in function block is: params : Arguments for the function. variadic_param : Variable-length argument list. It can be omitted. result : Return value. It can take not only just string but also other functions, variables, etc. Examples # function \"remove_ext\" { params = [ file ] result = replace ( basename ( file ), ext ( file ), \"\" ) } # \"${remove_ext(\" / path / to / secret . txt \")}\" => secret variable \"shortened_environment\" { description = \"Shortened environment, such as prod, dev\" type = \"map\" default = { production = \"prod\" development = \"dev\" laboratory = \"lab\" } } function \"shorten_env\" { params = [ env ] result = lookup ( var . shortened_environment , env ) } # $ { shorten_env ( \"development\" )} => dev","title":"Custom Functions"},{"location":"configuration/syntax/custom-functions/#whats-custom-functions","text":"The custom function feature is like an user-defined functions. You can freely define functions that Stein doesn't provide as a built-in function . Of course you can define it freely, so you can customize it by wrapping a built-in function, or you can use it like an alias.","title":"What's custom functions?"},{"location":"configuration/syntax/custom-functions/#why-need-custom-functions","text":"Stein functions as a versatile testing framework for configuration files such as YAML. Stein therefore doesn't provide a function only to achieve a specific company's use case or purpose. However, there will be many cases in which you want to do it. This custom function feature covers that.","title":"Why need custom functions?"},{"location":"configuration/syntax/custom-functions/#usage","text":"This HCL extension allows a calling application to support user-defined functions. Functions are defined via a specific block type, like this: function \"add\" { params = [ a , b ] result = a + b } function \"list\" { params = [] variadic_param = items result = items } Predefined keywords to be used in function block is: params : Arguments for the function. variadic_param : Variable-length argument list. It can be omitted. result : Return value. It can take not only just string but also other functions, variables, etc.","title":"Usage"},{"location":"configuration/syntax/custom-functions/#examples","text":"function \"remove_ext\" { params = [ file ] result = replace ( basename ( file ), ext ( file ), \"\" ) } # \"${remove_ext(\" / path / to / secret . txt \")}\" => secret variable \"shortened_environment\" { description = \"Shortened environment, such as prod, dev\" type = \"map\" default = { production = \"prod\" development = \"dev\" laboratory = \"lab\" } } function \"shorten_env\" { params = [ env ] result = lookup ( var . shortened_environment , env ) } # $ { shorten_env ( \"development\" )} => dev","title":"Examples"},{"location":"configuration/syntax/interpolation/","text":"Interpolation Syntax # Embedded within strings in Terraform, whether you're using the Terraform syntax or JSON syntax, you can interpolate other values. These interpolations are wrapped in ${} , such as ${ var . foo } . The interpolation syntax is powerful and allows you to reference variables, attributes of resources, call functions, etc. You can perform simple math in interpolations, allowing you to write conditions such as ${ count . index + 1 } . And you can also use conditionals to determine a value based on some logic. You can escape interpolation with double dollar signs: $${foo} will be rendered as a literal ${ foo } . Available Variables # There are a variety of available variable references you can use. User string variables # Use the var.prefix followed by the variable name. For example, ${ var . foo } will interpolate the foo variable value. User map variables # The syntax is var.MAP[\"KEY\"] . For example, ${ var . amis [ \"us-east-1\" ] } would get the value of the us-east-1 key within the amis map variable. User list variables # The syntax is \" ${ var . LIST } \" . For example, \" ${ var . subnets } \" would get the value of the subnets list, as a list. You can also return list elements by index: ${ var . subnets [ idx ] } . Path information # WIP The syntax is path.TYPE . TYPE can be file , dir , or policies . cwd will interpolate the current working directory. module will interpolate the path to the current module. root will interpolate the path of the root module. In general, you probably want the path.module variable. \" ${ path . file } \" # => manifests/microservices/x-gateway-jp/development/Service/a.yaml # [Notes] # this variable is an alias of `filename` variable \" ${ path . dir } \" # => manifests/microservices/x-gateway-jp/development/Service Predefined variables # filename : Filename to be applied policy (alias of path.policy ) Environment variables information # The syntax is env.ENV . ENV can be USER , HOME , etc. These values comes from env command output. \" ${ env . HOME } \" # => /home/username \" ${ env . EDITOR } \" # => vim Conditionals # Interpolations may contain conditionals to branch on the final value. \" ${ var . user == \"john\" ? var . member : env . anonymous } \" # => var.member (if var.user is john) # => var.anonymous (if var.user is not john) The conditional syntax is the well-known ternary operation: CONDITION ? TRUEVAL : FALSEVAL The condition can be any valid interpolation syntax, such as variable access, a function call, or even another conditional. The true and false value can also be any valid interpolation syntax. The returned types by the true and false side must be the same. The supported operators are: Equality: == and != Numerical comparison: > , < , >= , <= Boolean logic: && , || , unary ! Built-in Functions # Stein ships with built-in functions. Functions are called with the syntax name(arg, arg2, ...) . For example, to read a file: ${ file ( \"path.txt\" ) } . Stein supports all Terraform's built-in functions listed in this page . In addition to these functions, it also comes with the original built-in functions to make it even easier to write rules. For more details, please see also Built-in Functions in Navigation bar on left. Custom Functions # While supporting some useful built-in functions, Stein allows to create user-defined functions. function \"add\" { params = [ a , b ] result = a + b } \" ${ add ( 1 , 3 ) } \" # => 4 For more details, please see also Custom Functions Math # Almost the same as Terraform Math mechanism.","title":"Interpolation"},{"location":"configuration/syntax/interpolation/#interpolation-syntax","text":"Embedded within strings in Terraform, whether you're using the Terraform syntax or JSON syntax, you can interpolate other values. These interpolations are wrapped in ${} , such as ${ var . foo } . The interpolation syntax is powerful and allows you to reference variables, attributes of resources, call functions, etc. You can perform simple math in interpolations, allowing you to write conditions such as ${ count . index + 1 } . And you can also use conditionals to determine a value based on some logic. You can escape interpolation with double dollar signs: $${foo} will be rendered as a literal ${ foo } .","title":"Interpolation Syntax"},{"location":"configuration/syntax/interpolation/#available-variables","text":"There are a variety of available variable references you can use.","title":"Available Variables"},{"location":"configuration/syntax/interpolation/#user-string-variables","text":"Use the var.prefix followed by the variable name. For example, ${ var . foo } will interpolate the foo variable value.","title":"User string variables"},{"location":"configuration/syntax/interpolation/#user-map-variables","text":"The syntax is var.MAP[\"KEY\"] . For example, ${ var . amis [ \"us-east-1\" ] } would get the value of the us-east-1 key within the amis map variable.","title":"User map variables"},{"location":"configuration/syntax/interpolation/#user-list-variables","text":"The syntax is \" ${ var . LIST } \" . For example, \" ${ var . subnets } \" would get the value of the subnets list, as a list. You can also return list elements by index: ${ var . subnets [ idx ] } .","title":"User list variables"},{"location":"configuration/syntax/interpolation/#path-information","text":"WIP The syntax is path.TYPE . TYPE can be file , dir , or policies . cwd will interpolate the current working directory. module will interpolate the path to the current module. root will interpolate the path of the root module. In general, you probably want the path.module variable. \" ${ path . file } \" # => manifests/microservices/x-gateway-jp/development/Service/a.yaml # [Notes] # this variable is an alias of `filename` variable \" ${ path . dir } \" # => manifests/microservices/x-gateway-jp/development/Service","title":"Path information"},{"location":"configuration/syntax/interpolation/#predefined-variables","text":"filename : Filename to be applied policy (alias of path.policy )","title":"Predefined variables"},{"location":"configuration/syntax/interpolation/#environment-variables-information","text":"The syntax is env.ENV . ENV can be USER , HOME , etc. These values comes from env command output. \" ${ env . HOME } \" # => /home/username \" ${ env . EDITOR } \" # => vim","title":"Environment variables information"},{"location":"configuration/syntax/interpolation/#conditionals","text":"Interpolations may contain conditionals to branch on the final value. \" ${ var . user == \"john\" ? var . member : env . anonymous } \" # => var.member (if var.user is john) # => var.anonymous (if var.user is not john) The conditional syntax is the well-known ternary operation: CONDITION ? TRUEVAL : FALSEVAL The condition can be any valid interpolation syntax, such as variable access, a function call, or even another conditional. The true and false value can also be any valid interpolation syntax. The returned types by the true and false side must be the same. The supported operators are: Equality: == and != Numerical comparison: > , < , >= , <= Boolean logic: && , || , unary !","title":"Conditionals"},{"location":"configuration/syntax/interpolation/#built-in-functions","text":"Stein ships with built-in functions. Functions are called with the syntax name(arg, arg2, ...) . For example, to read a file: ${ file ( \"path.txt\" ) } . Stein supports all Terraform's built-in functions listed in this page . In addition to these functions, it also comes with the original built-in functions to make it even easier to write rules. For more details, please see also Built-in Functions in Navigation bar on left.","title":"Built-in Functions"},{"location":"configuration/syntax/interpolation/#custom-functions","text":"While supporting some useful built-in functions, Stein allows to create user-defined functions. function \"add\" { params = [ a , b ] result = a + b } \" ${ add ( 1 , 3 ) } \" # => 4 For more details, please see also Custom Functions","title":"Custom Functions"},{"location":"configuration/syntax/interpolation/#math","text":"Almost the same as Terraform Math mechanism.","title":"Math"},{"location":"configuration/syntax/functions/color/","text":"color(text, color) # Returns a string colorized by the color name. Type # Arguments Return values string, string string Usage # \" ${ color ( \"hello!\" , \"white\" ) } \" # => \"\\x1b[37mhello!\\x1b[0m\" \" ${ color ( \"hello!\" , \"red\" , \"BgBlack\" ) } \" # => \"\\x1b[31m\\x1b[40mhello!\\x1b[0m\"","title":"color"},{"location":"configuration/syntax/functions/color/#colortext-color","text":"Returns a string colorized by the color name.","title":"color(text, color)"},{"location":"configuration/syntax/functions/color/#type","text":"Arguments Return values string, string string","title":"Type"},{"location":"configuration/syntax/functions/color/#usage","text":"\" ${ color ( \"hello!\" , \"white\" ) } \" # => \"\\x1b[37mhello!\\x1b[0m\" \" ${ color ( \"hello!\" , \"red\" , \"BgBlack\" ) } \" # => \"\\x1b[31m\\x1b[40mhello!\\x1b[0m\"","title":"Usage"},{"location":"configuration/syntax/functions/exist/","text":"exist(path) # Returns true if given file or directory exists Type # Arguments Return values string boolean Usage # \" ${ exist ( \"/path/to/whatever\" ) } \" # => true (if exists)","title":"exist"},{"location":"configuration/syntax/functions/exist/#existpath","text":"Returns true if given file or directory exists","title":"exist(path)"},{"location":"configuration/syntax/functions/exist/#type","text":"Arguments Return values string boolean","title":"Type"},{"location":"configuration/syntax/functions/exist/#usage","text":"\" ${ exist ( \"/path/to/whatever\" ) } \" # => true (if exists)","title":"Usage"},{"location":"configuration/syntax/functions/ext/","text":"ext(file) # Returns the file extensions. Type # Arguments Return values string string Usage # \" ${ ext ( \"a.txt\" ) } \" # => \".txt\"","title":"ext"},{"location":"configuration/syntax/functions/ext/#extfile","text":"Returns the file extensions.","title":"ext(file)"},{"location":"configuration/syntax/functions/ext/#type","text":"Arguments Return values string string","title":"Type"},{"location":"configuration/syntax/functions/ext/#usage","text":"\" ${ ext ( \"a.txt\" ) } \" # => \".txt\"","title":"Usage"},{"location":"configuration/syntax/functions/glob/","text":"glob(pattern) # Return an array of filenames or directories that matches the specified pattern. Type # Arguments Return type string list(string) Usage # \" ${ glob ( \"*.txt\" ) } \" The output of the code above could be: [\"a.txt\", \"b.txt\", \"c.txt\"]","title":"glob"},{"location":"configuration/syntax/functions/glob/#globpattern","text":"Return an array of filenames or directories that matches the specified pattern.","title":"glob(pattern)"},{"location":"configuration/syntax/functions/glob/#type","text":"Arguments Return type string list(string)","title":"Type"},{"location":"configuration/syntax/functions/glob/#usage","text":"\" ${ glob ( \"*.txt\" ) } \" The output of the code above could be: [\"a.txt\", \"b.txt\", \"c.txt\"]","title":"Usage"},{"location":"configuration/syntax/functions/grep/","text":"grep(pattern, text) # Returns the text block matched with the given pattern. Type # Arguments Return values string string Usage # My life didn't please me, so I created my life. - Coco Chanel \" ${ grep ( file ( \"text.txt\" ), \"life\" ) } \" # => \"My life didn't please me,\\nso I created my life.\"","title":"grep"},{"location":"configuration/syntax/functions/grep/#greppattern-text","text":"Returns the text block matched with the given pattern.","title":"grep(pattern, text)"},{"location":"configuration/syntax/functions/grep/#type","text":"Arguments Return values string string","title":"Type"},{"location":"configuration/syntax/functions/grep/#usage","text":"My life didn't please me, so I created my life. - Coco Chanel \" ${ grep ( file ( \"text.txt\" ), \"life\" ) } \" # => \"My life didn't please me,\\nso I created my life.\"","title":"Usage"},{"location":"configuration/syntax/functions/jsonpath/","text":"jsonpath(query) # This function returns the value corresponding to given query. The query should be followed JSONPATH. However, as of now, this jsonpath function uses tidwall/gjson package as JSONPATH internally. So basically for now, please refer to its godoc page . Type # Arguments Return values string string / number / list / map Usage # Let's say you run some queries with jsonpath function in your rule file against the following Kubernetes Deployment manifest file. A example manifest file for Kubernetes Deployment These config files listed with three format are the same. Technically Kubernetes allows to accept only JSON and YAML as manifest file. A HCL code listed here is just a example for explaining HCL is the compatible for JSON and YAML. JSON { \"apiVersion\" : \"extensions/v1beta1\" , \"kind\" : \"Deployment\" , \"metadata\" : { \"name\" : \"nginx\" }, \"spec\" : { \"replicas\" : 2 , \"template\" : { \"metadata\" : { \"labels\" : { \"run\" : \"nginx\" } }, \"spec\" : { \"containers\" : [ { \"name\" : \"nginx\" , \"image\" : \"nginx:1.11\" , \"ports\" : [ { \"containerPort\" : 80 } ] } ] } } } } YAML apiVersion : extensions/v1beta1 kind : Deployment metadata : name : nginx spec : replicas : 2 template : metadata : labels : run : nginx spec : containers : - name : nginx image : nginx:1.11 ports : - containerPort : 80 HCL \"apiVersion\" = \"extensions/v1beta1\" \"kind\" = \"Deployment\" \"metadata\" = { \"name\" = \"nginx\" } \"spec\" = { \"replicas\" = 2 \"template\" \"metadata\" \"labels\" { \"run\" = \"nginx\" } \"template\" \"spec\" { \"containers\" = { \"image\" = \"nginx:1.11\" \"name\" = \"nginx\" \"ports\" = { \"containerPort\" = 80 } } } } First, let's say to use this query against above manifest file. jsonpath(\"spec.replicas\") It will return 2 (type is number).","title":"jsonpath"},{"location":"configuration/syntax/functions/jsonpath/#jsonpathquery","text":"This function returns the value corresponding to given query. The query should be followed JSONPATH. However, as of now, this jsonpath function uses tidwall/gjson package as JSONPATH internally. So basically for now, please refer to its godoc page .","title":"jsonpath(query)"},{"location":"configuration/syntax/functions/jsonpath/#type","text":"Arguments Return values string string / number / list / map","title":"Type"},{"location":"configuration/syntax/functions/jsonpath/#usage","text":"Let's say you run some queries with jsonpath function in your rule file against the following Kubernetes Deployment manifest file. A example manifest file for Kubernetes Deployment These config files listed with three format are the same. Technically Kubernetes allows to accept only JSON and YAML as manifest file. A HCL code listed here is just a example for explaining HCL is the compatible for JSON and YAML. JSON { \"apiVersion\" : \"extensions/v1beta1\" , \"kind\" : \"Deployment\" , \"metadata\" : { \"name\" : \"nginx\" }, \"spec\" : { \"replicas\" : 2 , \"template\" : { \"metadata\" : { \"labels\" : { \"run\" : \"nginx\" } }, \"spec\" : { \"containers\" : [ { \"name\" : \"nginx\" , \"image\" : \"nginx:1.11\" , \"ports\" : [ { \"containerPort\" : 80 } ] } ] } } } } YAML apiVersion : extensions/v1beta1 kind : Deployment metadata : name : nginx spec : replicas : 2 template : metadata : labels : run : nginx spec : containers : - name : nginx image : nginx:1.11 ports : - containerPort : 80 HCL \"apiVersion\" = \"extensions/v1beta1\" \"kind\" = \"Deployment\" \"metadata\" = { \"name\" = \"nginx\" } \"spec\" = { \"replicas\" = 2 \"template\" \"metadata\" \"labels\" { \"run\" = \"nginx\" } \"template\" \"spec\" { \"containers\" = { \"image\" = \"nginx:1.11\" \"name\" = \"nginx\" \"ports\" = { \"containerPort\" = 80 } } } } First, let's say to use this query against above manifest file. jsonpath(\"spec.replicas\") It will return 2 (type is number).","title":"Usage"},{"location":"configuration/syntax/functions/lookuplist/","text":"lookuplist(map, key) # Returns a list matched by the key in the given map. Like the Terraform's lookup but this is only for returning a list. Type # Arguments Return values map, string list(string) Usage # variable \"colors\" { type = \"map\" default = { \"red\" = [ \"burgundy\", \"terracotta\", \"scarlet\", ] \"blue\" = [ \"heliotrope\", \"cerulean blue\", \"turquoise blue\", ] } } \" ${ lookuplist ( var . colors , \"red\" ) } \" # => [\"burgundy\", \"terracotta\", \"scarlet\"] \" ${ contains ( lookuplist ( var . colors , \"red\" ), \"scarlet\" ) } \" # => true","title":"lookuplist"},{"location":"configuration/syntax/functions/lookuplist/#lookuplistmap-key","text":"Returns a list matched by the key in the given map. Like the Terraform's lookup but this is only for returning a list.","title":"lookuplist(map, key)"},{"location":"configuration/syntax/functions/lookuplist/#type","text":"Arguments Return values map, string list(string)","title":"Type"},{"location":"configuration/syntax/functions/lookuplist/#usage","text":"variable \"colors\" { type = \"map\" default = { \"red\" = [ \"burgundy\", \"terracotta\", \"scarlet\", ] \"blue\" = [ \"heliotrope\", \"cerulean blue\", \"turquoise blue\", ] } } \" ${ lookuplist ( var . colors , \"red\" ) } \" # => [\"burgundy\", \"terracotta\", \"scarlet\"] \" ${ contains ( lookuplist ( var . colors , \"red\" ), \"scarlet\" ) } \" # => true","title":"Usage"},{"location":"configuration/syntax/functions/match/","text":"match(text, text) # Returns a true if the text is matched with the pattern. Type # Arguments Return values string, string boolean Usage # \" ${ match ( \"abcdef\" , \"^a\" ) } \" # => true","title":"match"},{"location":"configuration/syntax/functions/match/#matchtext-text","text":"Returns a true if the text is matched with the pattern.","title":"match(text, text)"},{"location":"configuration/syntax/functions/match/#type","text":"Arguments Return values string, string boolean","title":"Type"},{"location":"configuration/syntax/functions/match/#usage","text":"\" ${ match ( \"abcdef\" , \"^a\" ) } \" # => true","title":"Usage"},{"location":"configuration/syntax/functions/pathshorten/","text":"pathshorten(path) # Returns the file path shortened like Vim's one . Type # Arguments Return values string string Usage # \" ${ pathshorten ( \"manifests/microservices/x-gateway-jp/development/Service/a.yaml\" ) } \" # => \"m/m/x/d/S/a.yaml\"","title":"pathshorten"},{"location":"configuration/syntax/functions/pathshorten/#pathshortenpath","text":"Returns the file path shortened like Vim's one .","title":"pathshorten(path)"},{"location":"configuration/syntax/functions/pathshorten/#type","text":"Arguments Return values string string","title":"Type"},{"location":"configuration/syntax/functions/pathshorten/#usage","text":"\" ${ pathshorten ( \"manifests/microservices/x-gateway-jp/development/Service/a.yaml\" ) } \" # => \"m/m/x/d/S/a.yaml\"","title":"Usage"},{"location":"configuration/syntax/functions/wc/","text":"wc(text, [l, c, w]) # Returns the counted number of text as options ( l ines, w ords, c hars). Default option is l ines. Same as UNIX's one. Type # Arguments Return values string, (string...) number Usage # \" ${ wc ( \"foo \\n bar baz\" ) } \" # => 1 \" ${ wc ( \"foo \\n bar baz\" , \"c\" ) } \" # => 11 \" ${ wc ( \"foo \\n bar baz\" , \"w\" ) } \" # => 3","title":"wc"},{"location":"configuration/syntax/functions/wc/#wctext-l-c-w","text":"Returns the counted number of text as options ( l ines, w ords, c hars). Default option is l ines. Same as UNIX's one.","title":"wc(text, [l, c, w])"},{"location":"configuration/syntax/functions/wc/#type","text":"Arguments Return values string, (string...) number","title":"Type"},{"location":"configuration/syntax/functions/wc/#usage","text":"\" ${ wc ( \"foo \\n bar baz\" ) } \" # => 1 \" ${ wc ( \"foo \\n bar baz\" , \"c\" ) } \" # => 11 \" ${ wc ( \"foo \\n bar baz\" , \"w\" ) } \" # => 3","title":"Usage"},{"location":"intro/install/","text":"Installing Stein is simple. There are two approaches to installing Stein: Using a precompiled binary Installing from source Downloading a precompiled binary is easiest, and we provide downloads over TLS along with SHA256 sums to verify the binary. We also distribute a PGP signature with the SHA256 sums that can be verified. Precompiled Binaries # To install the precompiled binary, download the appropriate package for your system. Stein is currently packaged as a zip file. We do not have any near term plans to provide system packages. Releases \u00b7 b4b4r07/stein Once the zip is downloaded, unzip it into any directory. The stein binary inside is all that is necessary to run Stein (or stein.exe for Windows). Any additional files, if any, aren't required to run Stein. Copy the binary to anywhere on your system. If you intend to access it from the command-line, make sure to place it somewhere on your PATH . Compiling from Source # To compile from source, you will need Go installed and configured properly (including a GOPATH environment variable set), as well as a copy of git in your PATH . First, clone the Stein repository from GitHub into your GOPATH : $ mkdir -p $GOPATH /src/github.com/b4b4r07 && cd $_ $ git clone https://github.com/b4b4r07/stein.git $ cd stein Then, build Stein for your current system and put the binary in ./bin/ (relative to the git checkout). The make dev target is just a shortcut that builds stein for only your local build environment (no cross-compiled targets). $ make build Verifying the Installation # To verify Stein is properly installed, run stein -h on your system. You should see help output. If you are executing it from the command line, make sure it is on your PATH or you may get an error about Stein not being found. $ stein -h","title":"Installing Stein"},{"location":"intro/install/#precompiled-binaries","text":"To install the precompiled binary, download the appropriate package for your system. Stein is currently packaged as a zip file. We do not have any near term plans to provide system packages. Releases \u00b7 b4b4r07/stein Once the zip is downloaded, unzip it into any directory. The stein binary inside is all that is necessary to run Stein (or stein.exe for Windows). Any additional files, if any, aren't required to run Stein. Copy the binary to anywhere on your system. If you intend to access it from the command-line, make sure to place it somewhere on your PATH .","title":"Precompiled Binaries"},{"location":"intro/install/#compiling-from-source","text":"To compile from source, you will need Go installed and configured properly (including a GOPATH environment variable set), as well as a copy of git in your PATH . First, clone the Stein repository from GitHub into your GOPATH : $ mkdir -p $GOPATH /src/github.com/b4b4r07 && cd $_ $ git clone https://github.com/b4b4r07/stein.git $ cd stein Then, build Stein for your current system and put the binary in ./bin/ (relative to the git checkout). The make dev target is just a shortcut that builds stein for only your local build environment (no cross-compiled targets). $ make build","title":"Compiling from Source"},{"location":"intro/install/#verifying-the-installation","text":"To verify Stein is properly installed, run stein -h on your system. You should see help output. If you are executing it from the command line, make sure it is on your PATH or you may get an error about Stein not being found. $ stein -h","title":"Verifying the Installation"},{"location":"intro/rules/","text":"Let's say you want to create a policy for the next YAML file. apiVersion : v1 metadata : name : my-service # namespace: echo <-- OMITTED spec : selector : app : MyApp ports : - protocol : TCP port : 80 targetPort : 9376 This is Kubernetes YAML of Service manifest. The field metadata.namespace in Service can be omitted. However, let's say you want to define it explicitly and force the owner to specify this. In such a case, rule block is useful. A rule is simple block which can be represented by simple DSL schema by using HCL. The rule suitable for this case is as follows. rule \"namespace_specification\" { description = \"Check namespace name is not empty\" conditions = [ \" ${ jsonpath ( \"metadata.namespace\" ) != \"\" } \", ] report { level = \"ERROR\" message = \"Namespace is not specified\" } } The most important attributes in rule block is conditions list. This list is a collections of boolean values. If this list contains one or more false values, this rule will fail. The failed rule will output an error message according to the report block. By the way, jsonpath is provided as a built-in function. The available functions are here: Interpolation Syntax .","title":"Writing Stein rules"},{"location":"intro/run/","text":"Apply stein rules # After writing up your rules, let's run stein command. The Stein CLI is a well-behaved command line application. In erroneous cases, a non-zero exit status will be returned. It also responds to -h and --help as you'd expect. To view a list of the available commands at any time, just run stein with no arguments. To apply the rule to that YAML file and run the test you can do with the apply subcommand. $ stein apply -policy rules.hcl service.yaml service.yaml [ERROR] rule.namespace_specification Namespace is not specified ===================== 1 error(s), 0 warn(s) You can show the error message with exit code 1 . The location (a file path directly or a directory path which is located policies) of policy files can be specified with -policy flag. Otherwise, you can tell stein the location of policies with STEIN_POLICY environment variable. Moreover, stein automatically checks .policy directory whether policies written in HCL are located or not when running. So you can put it on .policy directory like the following: $ tree . service.yaml .policy/ `-- rules.hcl For more details about this behavior, see also How policies are loaded by Stein .","title":"Running Stein"},{"location":"intro/run/#apply-stein-rules","text":"After writing up your rules, let's run stein command. The Stein CLI is a well-behaved command line application. In erroneous cases, a non-zero exit status will be returned. It also responds to -h and --help as you'd expect. To view a list of the available commands at any time, just run stein with no arguments. To apply the rule to that YAML file and run the test you can do with the apply subcommand. $ stein apply -policy rules.hcl service.yaml service.yaml [ERROR] rule.namespace_specification Namespace is not specified ===================== 1 error(s), 0 warn(s) You can show the error message with exit code 1 . The location (a file path directly or a directory path which is located policies) of policy files can be specified with -policy flag. Otherwise, you can tell stein the location of policies with STEIN_POLICY environment variable. Moreover, stein automatically checks .policy directory whether policies written in HCL are located or not when running. So you can put it on .policy directory like the following: $ tree . service.yaml .policy/ `-- rules.hcl For more details about this behavior, see also How policies are loaded by Stein .","title":"Apply stein rules"}]}